resources:

  - name: pipeline_scriptRepobb
    type: gitRepo
    integration: github
    pointer:
      sourceName: "Varsha-Arun/sample_pipelines"
    #  buildOnPullRequestClose: true
    #  buildOnPullRequest: true
      branches:
        only:
          - shipctl
        #  - pr  
  
  - name: same_syncRepos
    type: gitRepo
    integration: github
    pointer:
      sourceName: "Varsha-Arun/sample_pipelines"
    #  buildOnPullRequestClose: true
    #  buildOnPullRequest: true
      branch: shipctl
          
  - name: ship_aws_cli
    type: cliConfig
    integration: "aws-new"
    pointer:
      sourceName : "clusternew"
      region: "us-east-1"
  
  - name: test_params
    type: params
    version:
      params:
        TEST: rc
        env: e1
    flags:
      - test_params
      
  - name: ship_dh_cli
    type: cliConfig
    integration: "docker"
    
  - name: test_paramsCLI
    type: params
    version:
      params:
        TESTcli1: rc1
    flags:
      - test_paramsCLI
      
jobs:  
  - name: shipctl_runsh
    type: runSh
    allowPublicAccess: false #never make this job allowPublicAccess: true since we have sensitive data
    steps:
      - IN: ship_aws_cli
      - IN: same_syncRepos
        switch: off
      - IN: ship_dh_cli
      #- IN: t3runcli
      - IN: test_paramsCLI
      - IN: test_params
      #- IN: runshscript
      - IN: pipeline_scriptRepobb
      #- OUT: test_out_img2
      - TASK:
        - script: echo "PIPELINE_SCRIPTREPOBB_STATE=$PIPELINE_SCRIPTREPOBB_STATE"
        - script: export testEnv=EnvFromJob
        - script: echo "testEnv=$testEnv"
        
        - echo "====================================================repeating this below====================================="
        - script: echo "--->get_resource_state"
        - script: MY_SHIPCTL_GET_RESOURCE_STATE="$(shipctl get_resource_state "test_paramsCLI")"
        - script: TEST="$"$MY_SHIPCTL_GET_RESOURCE_STATE""
        - script: echo "$TEST"
        
        - script: echo "--->shipctl copy_file_from_prev_state <filename> <topath>. Copies the file to the path supplied from the state folder of the previos run of the Job that is currently running."
        - script: shipctl copy_file_from_prev_state "test/jobs/config.json" "IN/same_syncRepos/gitRepo/test/jobs/config1.json"
        - script: cat "IN/same_syncRepos/gitRepo/test/jobs/config1.json"
        
       # - script: echo "---shipctl copy_file_from_resource_state <resource name> <filename> <topath>. Copies a file from the state of an IN resource to the specified path."
       # - script: shipctl copy_file_from_resource_state "test_params" "test/jobs/config.json"
        
        - script: echo "--->shipctl copy_file_to_state <filename>. Copies the file to the state folder of the Job that is currently running. This will be available to the next run of the Job or any future Jobs that use this as an IN"
        - script: shipctl copy_file_to_state "IN/same_syncRepos/gitRepo/test/jobs/testcopy.json"
        
        - script: echo "--->shipctl post_resource_state <resource name> <key> <value>. This posts the key-value to the state folder of the Resource. This action clears all state before adding the values specified. If you want to append a key-value pair to existing state, you should use put_resource_state utility."
        - script: shipctl post_resource_state "test_params" "env1" "e1post_resource_state"
        - script: echo "env1=$env1"
        
       # - script: echo "--->shipctl post_resource_state_multi <resource name> "<key1>=<value1> <key2>=<value2>". This posts multiple key-value pairs to the state folder of the Resource. This action clears all state before adding the values specified. If you want to append some key-value pairs to existing state, you should use put_resource_state_multi utility."
       # - script: shipctl post_resource_state_multi "test_paramsCLI" "TESTcli1 rc1poststate_multi TESTcli2 rc2poststate_multi"
       # - script: echo "TESTcli1=$TESTcli1"
       # - script: echo "TESTcli2=$TESTcli2"        
        
        - script: echo "---> shipctl put_resource_state <resource name> <key> <value>. This puts, i.e appends, the new key-value in the stage of the Resource. This utility will append to the state if it has already been created, else it will create a new one."
        - script: shipctl put_resource_state "test_paramsCLI" "TESTcli1" "rc1put_resource_state" 
        - script: echo "TESTcli1=$TESTcli1"
        
        - script: echo "---> shipctl put_resource_state_multi <resource name> <key> <value> <key> <value>. This puts, i.e appends, the new key-value pairs in the stage of the Resource. This utility will append to the state if it has already been created, else it will create a new one."
        - script: shipctl put_resource_state_multi "test_paramsCLI" "TESTcli1=rc1put_resource_state_multi TESTcli2=rc2put_resource_state_multi"  
        - script: echo "TESTcli1=$TESTcli1"
        - script: echo "TESTcli2=$TESTcli2" 
        
        - script: echo "---> shipctl refresh_file_to_state <filename>. This utility will look in the present working directory for the <filename> and if present, copy that to current Job state. If the file is not found, it will look in the state of the previous run of the Job and copy that to the current run's state. If the file doesn't exist there either, it will return an exit code of 0"
        - script:  shipctl refresh_file_to_state "test/jobs/config.json"
        
        - script: echo "---> shipctl get_resource_env <resource name> <env name>. Get an environment value specific to a particular resource or job. Rather than trying to figure out the sanitized ENV name to use, you can simply utilize this function with your exact resource name to get any special ENV that Shippable adds to your environment for each resource."
        - script: shipctl get_resource_env "test_paramsCLI" "TESTcli1"
        
        - script: echo "--->shipctl copy_resource_file_from_state <resource name> <filename> <topath>. Copies the file from the Resource State that was supplied as IN into the path supplied"
        - script: shipctl copy_resource_file_from_state "pipeline_scriptRepobb" "package.json" "IN/pipeline_scriptRepobb/gitRepo/copy.json"
        
        #- script: echo "--->shipctl decrypt <source filename> <key filename>. Uses the key-file to decryt the contents of source-file. This is typically used to decrypt stuff encrypted using Shippable keys on the fly, similar to how our encryption works. It avoids you having to build encrypt-decrypt system"
       # - script: shipctl decrypt "IN/same_syncRepos/gitRepo/key/accounts"
       # - script: cat "IN/same_syncRepos/gitRepo/key/accounts.decrypted" #accounts=decryptvalue secured value is in keys/accounts file
       
        - script: echo "--->shipctl get_json_value <filename> <field name>. Gets the json property value from the specified file. Fieldname supports . notation and [n] for arrays"
        - script: shipctl get_json_value "IN/same_syncRepos/gitRepo/test/jobs/properties.json" "properties[0].property1"
        
        - script: echo "get_integration_resource_field"
        - script: shipctl get_integration_resource_field "ship_dh_cli" "username"
        
        - script: echo "--->shipctl get_params_resource <resource name> <key name>. Gets the value for the given key present in an IN resource of type params. All the key-value pairs in params resource are available as environment variables and could be conveniently accessed from there."
        - script: shipctl get_params_resource "test_paramsCLI" "TESTcli1"
                
       # - script: echo "--->shipctl get_integration_resource_keys <resource name>. Gets all the possible keys from an integration used in an IN resource. The key values could be used with get_integration_resource_field command to get the value stored in the integration."
        #- script: shipctl get_integration_resource_keys "ddc_cluster"
        
        - script: echo "--->get_resource_id"
        - script: shipctl get_resource_id "ship_dh_cli"
        
        - script: echo "--->get_resource_meta"
        - script: shipctl get_resource_meta "test_paramsCLI"
        
        - script: echo "---> shipctl get_resource_name <resource name>. Gets the sanitized name for a given resource or job. This command uses sanitize_shippable_string command internally."
        - script: shipctl get_resource_name "test_paramsCLI"
        
        - script: echo "--->get_resource_operation"
        - script: shipctl get_resource_operation "ship_dh_cli"
        
        #- script: echo "---> shipctl get_resource_pointer_key <resource name> <key name>. Gets value for the given key present in the pointer of a IN resource."
        #- script: shipctl get_resource_pointer_key "deploy_img3" "sourceName"
        
        - script: echo "--->get_resource_state"
        - script: shipctl get_resource_state "test_paramsCLI"
        
        - script: echo "--->get_resource_type"
        - script: shipctl get_resource_type "ship_dh_cli"
        
        - script: echo "--->get_resource_version_id"
        - script: shipctl get_resource_version_id "runshscript"
        
        - script: echo "--->get_resource_version_name"
        - script: shipctl get_resource_version_name "runshscript"
        
        - script: echo "---> get_ resource_version_number"
        - script: shipctl get_resource_version_number "runshscript"
        
        - script: echo "--->get_resource_version_key"
        - script: shipctl get_resource_version_key "test_params" "TEST"
        
        - script: echo "--->post_resource_state"        
        - script: shipctl post_resource_state "test_paramsCLI" "TESTcli1" "rc2"
        - script: cat "/build/IN/test_paramsCLI/params" #echo "TESTcli2=$TESTcli2"
        
        - script: echo "--->put_resource_state"
        - script: shipctl put_resource_state "test_paramsCLI" "TESTcli1" "rc3"
        - script: cat "/build/IN/test_paramsCLI/params" #echo "TESTcli3=$TESTcli3"
        
        - script: echo "--->get_params_resource"
        - script: shipctl get_params_resource "test_paramsCLI" "TESTcli1"
        - script: echo "TESTcli1=$TESTcli1"
        
        - script: echo "--->get_integration_resource"
        - script: shipctl get_integration_resource "ship_dh_cli"
        
        - script: echo "--->shipctl refresh_file_to_out_path <filename> <resource name> Copies the file to the Resource State that was supplied as OUT"
        - script: shipctl refresh_file_to_out_path "test/jobs/sample.json" "test_out_img2"
        
        - script: echo "--->shipctl refresh_file_to_state <filename>. This will look in the present working directory for the <filename> and if present, copy that to current Job state. If it doesnt find the file, it will look in the state of the previos run of the Job and copy that. If it doesnt find it there, it just returns 0 exit code"
        - script: shipctl refresh_file_to_state "/test/jobs/config.json"
        
        - script: echo "shipctl replace <filename1> <filename2> <filenameN>. If you have a config file/s with a bunch of variables, you can use this utility to replace them all in one shot based on your current shell env. Your files need to have the placeholders in this format; $ENVIRONMENT_VARIABLE_NAME or ${ENVIRONMENT_VARIABLE_NAME}. The second option is the recommended one"
        - script: shipctl replace "IN/same_syncRepos/gitRepo/test/jobs/config.json" "IN/same_syncRepos/gitRepo/test/jobs/sample.json"
        
        - script: echo "--->retry command"
        - script: shipctl retry "echo 'hello'"
        
        - script: echo "--->sanitize_shippable_string"
        - script: shipctl sanitize_shippable_string "sanitize!@#$%^&*()-=+_[]{};,.<>"
        
        - script: echo "--->shipctl to_uppercase"
        - script: shipctl to_uppercase "uppercase!@#"
        - script: echo TESTcli1=$TESTcli1
